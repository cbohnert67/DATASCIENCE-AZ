<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 24: Projet Machine Learning (Partie 2)</title>
    <!-- Intégration de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Intégration de Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Intégration de MathJax -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Style personnalisé pour le corps du texte */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Style pour les titres avec un dégradé */
        .gradient-text {
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
        }
        /* Style pour les blocs de code */
        pre code {
            background-color: #1E293B; /* gray-800 */
            color: #E2E8F0; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            display: block;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* Styles for Python Syntax Highlighting */
        .code-keyword { color: #C586C0; } /* Magenta for keywords like def, if, for */
        .code-function { color: #DCDCAA; } /* Yellow for function names */
        .code-string { color: #CE9178; } /* Orange for strings */
        .code-comment { color: #6A9955; font-style: italic; } /* Green and italic for comments */
        .code-number { color: #B5CEA8; } /* Light green/blue for numbers */
        .code-builtin { color: #569CD6; } /* Blue for built-in functions like print */
        .code-operator { color: #d4d4d4; } /* Default color for operators */
        .code-variable { color: #9CDCFE; } /* Light blue for variables */
    </style>
</head>
<body class="bg-gray-900 text-gray-300">

    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight gradient-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-4">
                Chapitre 24 : Projet Machine Learning (Partie 2) - Entraîner et évaluer 3 modèles différents
            </h1>
        </header>

        <main class="space-y-10">

            <section class="bg-gray-800/50 p-6 rounded-lg border border-gray-700 shadow-lg">
                <p class="text-lg md:text-xl text-justify leading-relaxed">
                    Nos données sont prêtes et explorées. Nous avons compris les facteurs clés qui influencent le prix d'une maison et nous avons normalisé notre variable cible. Il est temps de passer à la phase la plus excitante : la modélisation !
                </p>
            </section>

            <section>
                <h2 class="text-3xl font-bold text-cyan-400 border-b-2 border-cyan-400/30 pb-2 mb-6">L'art de choisir son champion</h2>
                <div class="space-y-8">
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <h3 class="text-2xl font-bold text-blue-400 mb-3">L'importance d'avoir une baseline</h3>
                        <p class="mb-4 text-justify">
                            Avant de sortir les modèles les plus sophistiqués, il est crucial d'établir une baseline. C'est un modèle simple et rapide à entraîner qui nous donne un premier score de performance de référence. Pensez-y comme le "score minimum" à battre. 
                        </p>
                        <p class="mb-4 text-justify">
                           <strong>Analogie :</strong> Imaginez que vous construisez une voiture de course (un modèle complexe). Avant de la comparer à d'autres voitures de course, vous la compareriez d'abord à une voiture de tous les jours (votre baseline, par exemple une Régression Linéaire). Si votre voiture de course n'est même pas plus rapide que la voiture de base, c'est qu'il y a un gros problème dans sa conception.
                        </p>
                         <p class="mb-4 text-justify">
                           En Machine Learning, cela suit le principe du <strong>rasoir d'Ockham</strong> : entre deux modèles aux performances similaires, on préférera toujours le plus simple. Un modèle plus complexe doit donc prouver sa valeur en battant significativement la baseline. Si ce n'est pas le cas, sa complexité additionnelle (plus long à entraîner, plus difficile à interpréter) n'est pas justifiée.
                        </p>
                    </div>

                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <h3 class="text-2xl font-bold text-blue-400 mb-3">Revoir les métriques de régression</h3>
                        <p class="mb-4 text-justify">
                            Pour comparer nos modèles, nous avons besoin de juges impartiaux : les métriques d'évaluation. Pour un problème de régression, où l'on prédit une valeur continue, les deux plus courantes sont le RMSE et le R².
                        </p>
                        
                        <div class="mt-6 p-4 bg-gray-900/50 rounded-lg">
                            <h4 class="text-xl font-semibold text-white mb-2">RMSE (Root Mean Squared Error) - L'erreur moyenne</h4>
                            <p class="mb-4">
                                C'est la métrique la plus intuitive. Elle nous dit, en moyenne, de combien notre modèle se trompe. Elle est dans la même unité que notre variable cible.
                            </p>
                            <p class="text-center my-4 text-xl">
                                $$ RMSE = \sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y}_i)^2} $$
                            </p>
                            <p class="mb-4">Où :</p>
                            <ul class="list-disc list-inside space-y-1 mb-4">
                                <li> \(n\) est le nombre de maisons dans notre jeu de test.</li>
                                <li> \(y_i\) est le prix réel de la maison \(i\).</li>
                                <li> \(\hat{y}_i\) est le prix prédit par notre modèle pour la maison \(i\).</li>
                            </ul>
                            <p>
                                <strong>Interprétation :</strong> Le terme \((y_i - \hat{y}_i)\) est l'erreur pour une seule prédiction. On met cette erreur au carré pour deux raisons : pénaliser davantage les grosses erreurs et s'assurer que tout est positif. On fait ensuite la moyenne de ces erreurs au carré (c'est le <em>Mean Squared Error</em> ou MSE), et on prend la racine carrée pour revenir à l'unité d'origine (les dollars). Un RMSE de 25 000$ signifie qu'en moyenne, les prédictions de prix sont à 25 000$ du prix réel. <strong>Plus le RMSE est bas, mieux c'est.</strong>
                            </p>
                        </div>
                        
                        <div class="mt-6 p-4 bg-gray-900/50 rounded-lg">
                            <h4 class="text-xl font-semibold text-white mb-2">R² (Coefficient de détermination) - La part de variance expliquée</h4>
                            <p class="mb-4">
                                Le R² est une mesure relative. Il nous dit quelle proportion de la variation des prix des maisons notre modèle est capable d'expliquer, par rapport à un modèle naïf qui prédirait simplement le prix moyen pour toutes les maisons.
                            </p>
                             <p class="text-center my-4 text-xl">
                                $$ R^2 = 1 - \frac{\sum_{i=1}^{n}(y_i - \hat{y}_i)^2}{\sum_{i=1}^{n}(y_i - \bar{y})^2} $$
                            </p>
                            <p class="mb-4">Où \(\bar{y}\) est le prix moyen de toutes les maisons dans le jeu de test.</p>
                            <p class="mb-4">
                                <strong>Interprétation :</strong> Le numérateur est la somme des erreurs au carré de notre modèle. Le dénominateur est la somme des erreurs au carré si on avait simplement utilisé la moyenne comme prédiction.
                            </p>
                            <ul class="list-disc list-inside space-y-1">
                               <li>Si <strong>R² = 1</strong> : Le modèle est parfait, il explique 100% de la variabilité.</li>
                               <li>Si <strong>R² = 0.85</strong> : Le modèle explique 85% de la variabilité des prix. Les 15% restants sont dus à des facteurs non capturés par le modèle.</li>
                               <li>Si <strong>R² = 0</strong> : Le modèle n'est pas meilleur que de simplement prédire le prix moyen.</li>
                               <li>Si <strong>R² < 0</strong> : Le modèle est pire que de prédire le prix moyen, ce qui indique un très gros problème.</li>
                            </ul>
                             <p class="mt-2"><strong>Plus le R² est proche de 1, mieux c'est.</strong></p>
                        </div>
                    </div>
                </div>
            </section>
            
            <section>
                <h2 class="text-3xl font-bold text-cyan-400 border-b-2 border-cyan-400/30 pb-2 mb-6">La compétition des modèles</h2>
                <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 space-y-8">
                    <div>
                        <h3 class="text-2xl font-bold text-blue-400 mb-3">Le pouvoir des Pipelines : notre chaîne de montage</h3>
                        <p class="text-justify">
                            Nous allons utiliser des <strong>Pipelines</strong> Scikit-Learn. Un pipeline est une structure qui enchaîne plusieurs étapes de transformation de données avant d'appliquer un modèle final.
                        </p>
                        <p class="mt-4 text-justify">
                            <strong>Analogie :</strong> Pensez à une chaîne de montage automobile. La carrosserie brute (données brutes) entre d'un côté. Elle passe par plusieurs postes : peinture (imputation des valeurs manquantes), montage des roues (scaling), installation du moteur (encodage des variables)... À la fin, la voiture complète (les données prêtes) est inspectée (le modèle est entraîné).
                        </p>
                        <p class="mt-4 text-justify font-semibold text-cyan-300">
                            L'avantage crucial est d'éviter la <span class="italic">fuite de données (data leakage)</span>. En intégrant le prétraitement dans un pipeline, on s'assure que les informations de l'ensemble de test (par exemple, sa médiane ou sa moyenne) ne sont JAMAIS utilisées pour préparer l'ensemble d'entraînement. Le pipeline apprend les transformations (comme le `scaler`) uniquement sur `X_train` et ne fait que les appliquer sur `X_test`.
                        </p>
                    </div>

                    <div>
                        <h3 class="text-2xl font-bold text-blue-400 mb-3">Étape par étape : le code décortiqué</h3>
                        <p class="mb-4">Voici le processus complet, divisé en étapes logiques.</p>

                        <div class="space-y-4">
                            <h4 class="text-xl font-semibold text-white">1. Préparation initiale</h4>
                            <p>On charge les données, on sépare les caractéristiques (`X`) de la cible (`y`), et on applique la transformation logarithmique à `y` pour stabiliser sa distribution, comme vu au chapitre précédent.</p>
<pre><code><span class="code-comment"># Charger les données</span>
<span class="code-variable">df</span> = <span class="code-variable">pd</span>.<span class="code-function">read_csv</span>(<span class="code-string">'train.csv'</span>)

<span class="code-comment"># Séparer features (X) et cible (y)</span>
<span class="code-variable">X</span> = <span class="code-variable">df</span>.<span class="code-function">drop</span>(<span class="code-string">'SalePrice'</span>, <span class="code-variable">axis</span>=<span class="code-number">1</span>)
<span class="code-variable">y</span> = <span class="code-variable">np</span>.<span class="code-function">log1p</span>(<span class="code-variable">df</span>[<span class="code-string">'SalePrice'</span>])

<span class="code-comment"># Identifier les types de colonnes</span>
<span class="code-variable">numerical_features</span> = <span class="code-variable">X</span>.<span class="code-function">select_dtypes</span>(<span class="code-variable">include</span>=<span class="code-variable">np</span>.<span class="code-variable">number</span>).<span class="code-variable">columns</span>.<span class="code-function">tolist</span>()
<span class="code-variable">categorical_features</span> = <span class="code-variable">X</span>.<span class="code-function">select_dtypes</span>(<span class="code-variable">exclude</span>=<span class="code-variable">np</span>.<span class="code-variable">number</span>).<span class="code-variable">columns</span>.<span class="code-function">tolist</span>()
</code></pre>
                            
                            <h4 class="text-xl font-semibold text-white">2. Construction du préprocesseur</h4>
                            <p>On définit deux "mini-pipelines", un pour les données numériques et un pour les catégorielles. Ensuite, on les assemble avec `ColumnTransformer`, qui appliquera le bon traitement à chaque type de colonne.</p>
<pre><code><span class="code-comment"># Pipeline pour les variables numériques</span>
<span class="code-variable">numeric_transformer</span> = <span class="code-function">Pipeline</span>(<span class="code-variable">steps</span>=[
    (<span class="code-string">'imputer'</span>, <span class="code-function">SimpleImputer</span>(<span class="code-variable">strategy</span>=<span class="code-string">'median'</span>)),  <span class="code-comment"># Remplace les NaN par la médiane</span>
    (<span class="code-string">'scaler'</span>, <span class="code-function">StandardScaler</span>())              <span class="code-comment"># Centre et réduit les données</span>
])

<span class="code-comment"># Pipeline pour les variables catégorielles</span>
<span class="code-variable">categorical_transformer</span> = <span class="code-function">Pipeline</span>(<span class="code-variable">steps</span>=[
    (<span class="code-string">'imputer'</span>, <span class="code-function">SimpleImputer</span>(<span class="code-variable">strategy</span>=<span class="code-string">'most_frequent'</span>)), <span class="code-comment"># Remplace les NaN par la valeur la plus fréquente</span>
    (<span class="code-string">'onehot'</span>, <span class="code-function">OneHotEncoder</span>(<span class="code-variable">handle_unknown</span>=<span class="code-string">'ignore'</span>))   <span class="code-comment"># Crée des colonnes binaires</span>
])

<span class="code-comment"># Assemble les deux pipelines en un seul préprocesseur</span>
<span class="code-variable">preprocessor</span> = <span class="code-function">ColumnTransformer</span>(
    <span class="code-variable">transformers</span>=[
        (<span class="code-string">'num'</span>, <span class="code-variable">numeric_transformer</span>, <span class="code-variable">numerical_features</span>),
        (<span class="code-string">'cat'</span>, <span class="code-variable">categorical_transformer</span>, <span class="code-variable">categorical_features</span>)
    ])
</code></pre>

                            <h4 class="text-xl font-semibold text-white">3. Entraînement et Évaluation</h4>
                            <p>On divise les données, puis pour chaque modèle, on crée un pipeline final qui combine le `preprocessor` et le modèle (`regressor`). On entraîne ce pipeline et on évalue les résultats en n'oubliant pas de faire la transformation inverse (`np.expm1`) pour que nos métriques soient interprétables en dollars.</p>
<pre><code><span class="code-comment"># Diviser en train/test</span>
<span class="code-variable">X_train</span>, <span class="code-variable">X_test</span>, <span class="code-variable">y_train</span>, <span class="code-variable">y_test</span> = <span class="code-function">train_test_split</span>(<span class="code-variable">X</span>, <span class="code-variable">y</span>, <span class="code-variable">test_size</span>=<span class="code-number">0.2</span>, <span class="code-variable">random_state</span>=<span class="code-number">42</span>)

<span class="code-comment"># Dictionnaire contenant les modèles à tester</span>
<span class="code-variable">models</span> = {
    <span class="code-string">"Régression Linéaire"</span>: <span class="code-function">LinearRegression</span>(),
    <span class="code-string">"Forêt Aléatoire"</span>: <span class="code-function">RandomForestRegressor</span>(<span class="code-variable">random_state</span>=<span class="code-number">42</span>),
    <span class="code-string">"Gradient Boosting"</span>: <span class="code-function">GradientBoostingRegressor</span>(<span class="code-variable">random_state</span>=<span class="code-number">42</span>)
}

<span class="code-comment"># Boucle pour entraîner et évaluer chaque modèle</span>
<span class="code-keyword">for</span> <span class="code-variable">name</span>, <span class="code-variable">model</span> <span class="code-keyword">in</span> <span class="code-variable">models</span>.<span class="code-function">items</span>():
    <span class="code-comment"># Crée le pipeline final : Préprocesseur + Modèle</span>
    <span class="code-variable">final_pipeline</span> = <span class="code-function">Pipeline</span>(<span class="code-variable">steps</span>=[(<span class="code-string">'preprocessor'</span>, <span class="code-variable">preprocessor</span>),
                                         (<span class="code-string">'regressor'</span>, <span class="code-variable">model</span>)])
    
    <span class="code-variable">final_pipeline</span>.<span class="code-function">fit</span>(<span class="code-variable">X_train</span>, <span class="code-variable">y_train</span>)
    <span class="code-variable">y_pred_log</span> = <span class="code-variable">final_pipeline</span>.<span class="code-function">predict</span>(<span class="code-variable">X_test</span>)
    
    <span class="code-comment"># IMPORTANT : Revenir à l'échelle d'origine pour l'évaluation</span>
    <span class="code-variable">y_test_orig</span> = <span class="code-variable">np</span>.<span class="code-function">expm1</span>(<span class="code-variable">y_test</span>)
    <span class="code-variable">y_pred_orig</span> = <span class="code-variable">np</span>.<span class="code-function">expm1</span>(<span class="code-variable">y_pred_log</span>)
    
    <span class="code-comment"># Calculer les métriques</span>
    <span class="code-variable">rmse</span> = <span class="code-variable">np</span>.<span class="code-function">sqrt</span>(<span class="code-function">mean_squared_error</span>(<span class="code-variable">y_test_orig</span>, <span class="code-variable">y_pred_orig</span>))
    <span class="code-variable">r2</span> = <span class="code-function">r2_score</span>(<span class="code-variable">y_test_orig</span>, <span class="code-variable">y_pred_orig</span>)

    <span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"--- {name} ---"</span>)
    <span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"RMSE: ${rmse:,.2f}"</span>)
    <span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"R²: {r2:.4f}\n"</span>)
</code></pre>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-bold text-blue-400 mb-3">Analyse des résultats</h3>
                        <p class="text-justify mb-4">
                            Après avoir lancé le code, nous obtenons les performances pour chaque modèle. La Régression Linéaire (notre baseline) nous donne un point de départ. Les deux autres modèles, basés sur des arbres de décision, sont beaucoup plus puissants et devraient logiquement obtenir de meilleurs scores.
                        </p>
                        <p class="text-justify">
                            Typiquement, les résultats ressembleront à ceci (les valeurs exactes peuvent légèrement varier) :
                        </p>
                        <div class="overflow-x-auto mt-4">
                            <table class="w-full text-left rounded-lg overflow-hidden">
                                <thead class="bg-gray-700 text-cyan-300">
                                    <tr>
                                        <th class="p-3">Modèle</th>
                                        <th class="p-3">RMSE (erreur moyenne)</th>
                                        <th class="p-3">R² (part expliquée)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="bg-gray-800 border-t border-gray-700">
                                        <td class="p-3 font-semibold">Régression Linéaire</td>
                                        <td class="p-3">~ 40 000 $</td>
                                        <td class="p-3">~ 0.85</td>
                                    </tr>
                                    <tr class="bg-gray-900/50 border-t border-gray-700">
                                        <td class="p-3 font-semibold">Forêt Aléatoire</td>
                                        <td class="p-3">~ 30 000 $</td>
                                        <td class="p-3">~ 0.89</td>
                                    </tr>
                                    <tr class="bg-gray-800 border-t border-gray-700">
                                        <td class="p-3 font-semibold text-green-400">Gradient Boosting</td>
                                        <td class="p-3 text-green-400"><strong>~ 28 000 $</strong></td>
                                        <td class="p-3 text-green-400"><strong>~ 0.90</strong></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                         <p class="mt-4 text-justify">
                            <strong>Conclusion :</strong> Le Gradient Boosting est notre champion initial ! Il a le RMSE le plus bas et le R² le plus élevé. Il a largement battu notre baseline, justifiant ainsi sa complexité. C'est donc sur ce modèle que nous concentrerons nos efforts d'optimisation.
                        </p>
                    </div>
                </div>
            </section>

            <section class="bg-gray-800 p-6 rounded-lg border border-gray-700">
                <h2 class="text-2xl font-bold text-cyan-400 mb-4">Challenge pour vous ! L'optimisation des hyperparamètres</h2>
                <p class="text-lg text-justify mb-4">
                    Le Gradient Boosting a souvent les meilleures performances "brutes", mais il est très sensible à ses hyperparamètres. Un modèle bien optimisé peut faire une énorme différence.
                </p>
                <div class="bg-gray-700/50 p-4 rounded-md">
                    <h3 class="font-bold text-cyan-300 mb-2">Votre mission :</h3>
                    <ul class="list-decimal list-inside space-y-2">
                        <li>Utilisez <code>RandomizedSearchCV</code> de Scikit-Learn pour trouver une meilleure combinaison d'hyperparamètres (<code>n_estimators</code>, <code>learning_rate</code>, <code>max_depth</code>) pour le <code>GradientBoostingRegressor</code>. C'est une méthode qui teste plusieurs combinaisons aléatoires pour trouver la meilleure.</li>
                        <li>Entraînez ce modèle optimisé et comparez son score à celui du Random Forest par défaut et du Gradient Boosting par défaut. L'amélioration est-elle significative ?</li>
                    </ul>
                </div>
                 <details class="bg-gray-700 p-4 rounded-md cursor-pointer mt-4">
                    <summary class="font-bold text-cyan-300">Cliquez ici pour voir la solution et l'interprétation</summary>
<pre class="mt-4"><code><span class="code-keyword">from</span> <span class="code-variable">sklearn.model_selection</span> <span class="code-keyword">import</span> <span class="code-variable">RandomizedSearchCV</span>

<span class="code-comment"># Définir le pipeline avec le préprocesseur et le modèle</span>
<span class="code-variable">gb_pipeline</span> = <span class="code-function">Pipeline</span>(<span class="code-variable">steps</span>=[(<span class="code-string">'preprocessor'</span>, <span class="code-variable">preprocessor</span>),
                              (<span class="code-string">'regressor'</span>, <span class="code-function">GradientBoostingRegressor</span>(<span class="code-variable">random_state</span>=<span class="code-number">42</span>))])

<span class="code-comment"># Définir la grille des hyperparamètres à tester</span>
<span class="code-variable">param_dist</span> = {
    <span class="code-string">'regressor__n_estimators'</span>: [<span class="code-number">100</span>, <span class="code-number">200</span>, <span class="code-number">500</span>, <span class="code-number">1000</span>],
    <span class="code-string">'regressor__learning_rate'</span>: [<span class="code-number">0.01</span>, <span class="code-number">0.05</span>, <span class="code-number">0.1</span>],
    <span class="code-string">'regressor__max_depth'</span>: [<span class="code-number">3</span>, <span class="code-number">4</span>, <span class="code-number">5</span>]
}

<span class="code-comment"># Configurer la recherche aléatoire</span>
<span class="code-variable">random_search</span> = <span class="code-function">RandomizedSearchCV</span>(
    <span class="code-variable">gb_pipeline</span>,
    <span class="code-variable">param_distributions</span>=<span class="code-variable">param_dist</span>,
    <span class="code-variable">n_iter</span>=<span class="code-number">10</span>, <span class="code-comment"># Nombre de combinaisons à tester</span>
    <span class="code-variable">cv</span>=<span class="code-number">5</span>,      <span class="code-comment"># Validation croisée sur 5 plis</span>
    <span class="code-variable">scoring</span>=<span class="code-string">'neg_root_mean_squared_error'</span>, <span class="code-comment"># Métrique à optimiser</span>
    <span class="code-variable">random_state</span>=<span class="code-number">42</span>,
    <span class="code-variable">n_jobs</span>=<span class="code-operator">-</span><span class="code-number">1</span> <span class="code-comment"># Utiliser tous les cœurs du CPU</span>
)

<span class="code-comment"># Lancer la recherche (sur les données log)</span>
<span class="code-variable">random_search</span>.<span class="code-function">fit</span>(<span class="code-variable">X_train</span>, <span class="code-variable">y_train</span>)

<span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"Meilleurs hyperparamètres trouvés : {random_search.best_params_}"</span>)

<span class="code-comment"># Évaluer le meilleur modèle trouvé</span>
<span class="code-variable">best_model</span> = <span class="code-variable">random_search</span>.<span class="code-variable">best_estimator_</span>
<span class="code-variable">y_pred_log_best</span> = <span class="code-variable">best_model</span>.<span class="code-function">predict</span>(<span class="code-variable">X_test</span>)

<span class="code-comment"># Revenir à l'échelle d'origine</span>
<span class="code-variable">y_test_orig</span> = <span class="code-variable">np</span>.<span class="code-function">expm1</span>(<span class="code-variable">y_test</span>)
<span class="code-variable">y_pred_orig_best</span> = <span class="code-variable">np</span>.<span class="code-function">expm1</span>(<span class="code-variable">y_pred_log_best</span>)

<span class="code-variable">rmse_best</span> = <span class="code-variable">np</span>.<span class="code-function">sqrt</span>(<span class="code-function">mean_squared_error</span>(<span class="code-variable">y_test_orig</span>, <span class="code-variable">y_pred_orig_best</span>))
<span class="code-variable">r2_best</span> = <span class="code-function">r2_score</span>(<span class="code-variable">y_test_orig</span>, <span class="code-variable">y_pred_orig_best</span>)

<span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"\n--- Gradient Boosting Optimisé ---"</span>)
<span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"RMSE: ${rmse_best:,.2f}"</span>)
<span class="code-builtin">print</span>(<span class="code-function">f</span><span class="code-string">"R²: {r2_best:.4f}\n"</span>)
</code></pre>
                </details>
            </section>

            <section id="quiz">
                <h2 class="text-3xl font-bold text-cyan-400 border-b-2 border-cyan-400/30 pb-2 mb-6">Testez vos connaissances !</h2>
                <div class="space-y-8">
                    <!-- Question 1 -->
                    <div class="quiz-question bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <p class="font-bold text-lg mb-4">1. Pourquoi établit-on une "baseline" avec un modèle simple comme la Régression Linéaire ?</p>
                        <div class="options grid grid-cols-1 md:grid-cols-2 gap-3">
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">a) Parce que c'est le modèle le plus performant.</button>
                            <button data-correct="true" class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">b) Pour avoir un score de référence à battre.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">c) Pour visualiser les données plus facilement.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">d) C'est une étape obligatoire dans Scikit-Learn.</button>
                        </div>
                        <div class="feedback hidden mt-4 p-3 rounded-md text-white"></div>
                    </div>
                    <!-- Question 2 -->
                    <div class="quiz-question bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <p class="font-bold text-lg mb-4">2. Un modèle obtient un R² de 0.90. Qu'est-ce que cela signifie ?</p>
                        <div class="options grid grid-cols-1 md:grid-cols-2 gap-3">
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">a) Le modèle fait des erreurs de 90$ en moyenne.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">b) Le modèle est correct dans 90% des cas.</button>
                            <button data-correct="true" class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">c) Le modèle explique 90% de la variabilité du prix des maisons.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">d) Le modèle est 10% moins bon que la perfection.</button>
                        </div>
                        <div class="feedback hidden mt-4 p-3 rounded-md text-white"></div>
                    </div>
                    <!-- Question 3 -->
                    <div class="quiz-question bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <p class="font-bold text-lg mb-4">3. À quoi sert un `Pipeline` dans Scikit-Learn ?</p>
                        <div class="options grid grid-cols-1 md:grid-cols-2 gap-3">
                             <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">a) À dessiner des graphiques de performance.</button>
                            <button data-correct="true" class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">b) À enchaîner des étapes de prétraitement et de modélisation de manière robuste.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">c) À choisir automatiquement le meilleur modèle.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">d) À importer les données depuis un fichier CSV.</button>
                        </div>
                        <div class="feedback hidden mt-4 p-3 rounded-md text-white"></div>
                    </div>
                     <!-- Question 4 -->
                    <div class="quiz-question bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <p class="font-bold text-lg mb-4">4. Pourquoi appliquons-nous une transformation logarithmique (np.log1p) sur la variable cible `SalePrice` ?</p>
                        <div class="options grid grid-cols-1 md:grid-cols-2 gap-3">
                            <button data-correct="true" class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">a) Pour normaliser sa distribution et stabiliser la variance.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">b) Pour convertir les prix en entiers.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">c) Parce que les modèles de régression ne fonctionnent qu'avec des logs.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">d) Pour accélérer l'entraînement du modèle.</button>
                        </div>
                        <div class="feedback hidden mt-4 p-3 rounded-md text-white"></div>
                    </div>
                    <!-- Question 5 -->
                    <div class="quiz-question bg-gray-800 p-6 rounded-lg border border-gray-700">
                        <p class="font-bold text-lg mb-4">5. Que fait `RandomizedSearchCV` ?</p>
                        <div class="options grid grid-cols-1 md:grid-cols-2 gap-3">
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">a) Il divise les données en un ensemble d'entraînement et de test de manière aléatoire.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">b) Il choisit un modèle au hasard parmi une liste.</button>
                            <button class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">d) Il teste toutes les combinaisons d'hyperparamètres possibles.</button>
                            <button data-correct="true" class="quiz-option w-full text-left p-3 rounded-md bg-gray-700 hover:bg-gray-600 transition">c) Il teste un nombre défini de combinaisons d'hyperparamètres aléatoires pour trouver la meilleure.</button>
                        </div>
                        <div class="feedback hidden mt-4 p-3 rounded-md text-white"></div>
                    </div>
                </div>
            </section>

            <section>
                <h2 class="text-3xl font-bold text-cyan-400 border-b-2 border-cyan-400/30 pb-2 mb-6">Questions pour aller plus loin</h2>
                 <div class="space-y-4 text-lg">
                    <p><strong>1. Le coût de la performance :</strong> Le Gradient Boosting est souvent plus performant, mais quel est son principal inconvénient par rapport à une Forêt Aléatoire en termes de temps d'entraînement et de sensibilité aux hyperparamètres ?</p>
                    <p><strong>2. L'importance de la transformation inverse :</strong> Pourquoi est-il crucial de faire la transformation inverse (`np.expm1`) sur les prédictions (`y_pred_log`) et la cible de test (`y_test`) avant de calculer le RMSE ? Qu'arriverait-il si on calculait le RMSE directement sur les données logarithmiques ?</p>
                    <p><strong>3. Au-delà du RMSE et du R² :</strong> Imaginez que vous présentez votre modèle à un agent immobilier. Le RMSE est une métrique technique. Comment pourriez-vous lui expliquer la performance de votre modèle en des termes plus concrets et utiles pour son métier (par exemple, en utilisant des pourcentages d'erreur ou des graphiques) ?</p>
                </div>
            </section>
        </main>

        <footer class="text-center mt-12 pt-8 border-t border-gray-700">
            <p class="text-gray-500">
                La Data Science de A à Z pour les lycéens
            </p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const quizQuestions = document.querySelectorAll('.quiz-question');
            quizQuestions.forEach(question => {
                const options = question.querySelectorAll('.quiz-option');
                const feedback = question.querySelector('.feedback');
                options.forEach(option => {
                    option.addEventListener('click', () => {
                        options.forEach(opt => {
                            opt.disabled = true;
                            opt.classList.remove('hover:bg-gray-600');
                        });
                        const isCorrect = option.getAttribute('data-correct') === 'true';
                        if (isCorrect) {
                            option.classList.remove('bg-gray-700');
                            option.classList.add('bg-green-500', 'text-white');
                            feedback.textContent = 'Bravo, c\'est la bonne réponse !';
                            feedback.classList.add('bg-green-500/30', 'border', 'border-green-500');
                        } else {
                            option.classList.remove('bg-gray-700');
                            option.classList.add('bg-red-500', 'text-white');
                            const correctOption = question.querySelector('[data-correct="true"]');
                            correctOption.classList.remove('bg-gray-700');
                            correctOption.classList.add('bg-green-500', 'text-white');
                            feedback.textContent = 'Dommage. La bonne réponse est mise en surbrillance en vert.';
                            feedback.classList.add('bg-red-500/30', 'border', 'border-red-500');
                        }
                        feedback.classList.remove('hidden');
                    });
                });
            });
        });
    </script>
</body>
</html>

